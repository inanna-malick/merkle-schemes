<!DOCTYPE html>
<html>
  <head>
    <title>Merkle Schemes 1</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
     .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
     .image-70 img {
        width: 70%;
      }
     .footer { position: absolute; bottom: 12px; left: 20px }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Merkle Schemes 1

---

layout:true

<div class="footer">Paul Kinsky, contact: pkinsky@gmail.com, twitter: @pseudo_morphism</div>

---

# Cryptographic Hash Functions

```
             +----------+
             |   hash   |
  text +-----+          +-----> hash
             | function |
             +----------+
```

- convert arbitrarily-sized inputs into fixed-size hashes
- one way: text cannot be recovered from a hash
- deterministic
- collision resistant
- 'digital fingerprint'

in haskell:

```haskell
newtype Hash = Hash { unHash :: CH.Digest CHA.SHA256 }

hash :: ByteString -> Hash
```

---
# Merkle Trees

.image-70[![Default-aligned image](images/Hash_Tree.png)]

A Merkle tree is a tree in which each node is annotated with the cryptographic hash of that node's text, which includes:
- the contents of that node, and
- the hashes of any nodes that it references

---

# Benefits of Merkle Trees

- Immutability via hash pinning
- Constant time equality checking of subtrees
    - diffing is O (n log(n)) with regard to the number of _changes_
    - not the number of entities in a tree
- Lazy traversal
- Structural sharing
- Easy caching

---

# Distributed Systems

Every distributed system designed since 2005 *has at least considered* Merkle trees

Some examples:
- Version control
    - Git
    - Mercurial
- Decentralized web
    - Bittorrent
    - Bitcoin/Blockchain
    - IPFS
- Build tools
    - Nix/NixOS (sort of)
    - Buck
    - Bazel

---

# Merkle Tree Implementation Note

.image-70[![Default-aligned image](images/Hash_Tree.png)]

Merkle trees are usually stored as a series of individual layers with recursive links replaced by hash pointers

---

# Merkle Trees for version control

Git and Mercurial use Merkle trees:
- Commit history
- Directory trees

Enables:
- Quick diffing
- Structural sharing
- Simplified caching


---

# Haskell Code Sketch: DirTree

simple directory tree (without any hash annotations):

```haskell
data DirTree
  = DirTree
  { entities :: [(FilePath, FileFileTreeEntity)]
  }

data FileTreeEntity
  = FileEntity String -- storing file contents inline for simplicity
  | DirEntity  DirTree
```

- top-level directory has no name (as in git)
- file are contents stored inline for simplicity - will change later

---

# Haskell Code Sketch: Low-level Structure

```haskell
newtype Hash = Hash { unHash :: CH.Digest CHA.SHA256 }

data HashableDirLayer
  = HashableDir
  { entities :: [(FilePath, HashableFileTreeEntity)
  }

data HashableFileTreeEntity
  = HashableFileEntity String -- storing file contents inline for simplicity
  | HashableDirEntity  Hash
```

Only difference: recursive `DirTree` parameter replaced with `Hash` pointer.

---

# Haskell Code Sketch: Refactor

There's a lot of code duplication here. Only one thing changes (the recursive parameter) between `Dir` and `HashableDirLayer`, can we instead use one type parameterized over that?

```haskell
data DirLayer a = DirLayer { entities :: [(FilePath, FileTreeEntity a)]}

data FileTreeEntity a
  = FileEntity String -- storing file contents inline for simplicity
  | DirEntity  a

```

Given this, a hashable layer is just:

```haskell
newtype Hash = Hash { unHash :: CH.Digest CHA.SHA256 }

type HashableDirLayer = DirLayer Hash
```

---

# Haskell Code Sketch: Refactor

But how do we represent the recursive case? Conceptually, we want something like this:

```haskell
myDir :: ???
myDir = DirLayer
      [ ("README.md" , FileEntity "foo")
      , ("dir2"      , DirEntity $ DirLayer [("Foo.hs", FileEntity "baz")])
      ]
```

But the resulting type is a mess: `Dirlayer (DirLayer (DirLayer ...))`

---

# Haskell Code Sketch: Fix

```haskell
data DirLayer a = DirLayer { entities :: [(FilePath, FileTreeEntity a)]}

data FileTreeEntity a
  = FileEntity String -- storing file contents inline for simplicity
  | DirEntity  a

```

Solution: take the type-level fix point of `Dir`

```haskell
newtype Fix f = Fix { unFix :: f (Fix f) }

type DirTree = Fix DirLayer

myDir :: DirTree
myDir = Fix $ DirLayer
      [ ("README.md" , FileEntity "foo")
      , ("dir2"      , DirEntity $ Fix $ DirLayer [("Foo.hs", FileEntity "baz")])
      ]

```

---

# Recursion Schemes!

- This format gives us access to some truly powerful abstractions:
- Recursion schemes let us _generalize_ over fold and unfold
- Like how for loops _generalize_ over goto

---

# Hashing a directory tree

```haskell
hashLayer :: DirLayer Hash -> Hash
hashLayer = hash . BL.toStrict . AE.encode
```

All you need to do is write a function to hash a layer!

```haskell
cata :: Functor f => (f a -> a) -> Fix f -> a

hashDirTree :: DirTree -> Hash
hashDirTree = cata hashLayer
```


---

# Writing a directory tree to disk

```haskell
-- | write a single directory layer to a file system store
writeLayer :: FilePath -> DirLayer Hash -> IO Hash
writeLayer baseDir layer = do
  let h = hashLayer layer
      path = hashToPath baseDir h
  AE.encodeFile path layer -- write dir layer to path
  pure h
```

All you need to do is write a function to write a layer to the store!

```haskell
cataM :: (Monad m, Traversable f) => (f a -> m a) -> Fix f -> m a

-- | write a directory tree to a filesystem store
writeDirTree :: FilePath -> DirTree -> IO Hash
writeDirTree baseDir = cataM (writeLayer baseDir)
```

---

# Reading a directory tree from disk

```haskell
-- | read a single directory layer from a file system store
readLayer :: FilePath -> Hash -> IO (DirLayer Hash)
readLayer baseDir h = do
  res <- AE.decodeFileStrict (hashToPath baseDir h)
  case res of
    Nothing -> fail "hash deref failed"
    Just  x -> pure x
```

All you need to do is write a function to retrieve a layer from the store!

```haskell
anaM :: (Monad m, Traversable f) => (a -> m (f a)) -> a -> m (Fix f)

-- | read a directory tree to a filesystem store
readDirTree :: FilePath -> Hash -> IO DirTree
readDirTree baseDir = anaM (readLayer baseDir)
```

---

# Break for questions

Next talk:
- Use recursion schemes to implement some simple fold/unfold type functions
- Write a directory diffing algorithm to compare two `DirTree`s

---




    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
