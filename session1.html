<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Merkle Schemes 1

---

# Introduction/Intro story/heres why u should care type thing?

---

# Cryptographic Hash Functions

```
             +----------+
             |   hash   |
  text +-----+          +-----> hash
             | function |
             +----------+
```

- convert arbitrarily-sized inputs into fixed-size hashes
- one way: text cannot be recovered from a hash
- deterministic
- collision resistant
- 'digital fingerprint'

in haskell:

```haskell
hashFunction :: ByteString -> Hash
```

---

below slides still need work

todo: note on Dags vs. trees needs to go somewhere

---
# Merkle Trees

img: full tree with hash pointers subtantiated

A Merkle tree is a tree in which each node is annotated with the cryptographic hash of that node's text, which includes the contents of that node and the hashes of any nodes that it references

^ needs work

---

# Benefits of Merkle Trees

Git and Mercurial use Merkle Trees to represent repository directory trees

- Immutability
- Quick comparison (`O(1)`)
- Lazy traversal
- Structural sharing
- Easy caching

---

# Distributed Systems

Every distributed system designed since 2005 *has at least considered* Merkle trees

Some examples:
- Version control
    - Git
    - Mercurial
- Decentralized web
    - Bittorrent 
    - Bitcoin/Blockchain
    - IPFS
- Build tools
    - Nix/NixOS (sort of)
    - Buck
    - Bazel

---

# Merkle Trees

img: individual layer

Each node in a Merkle tree has some content and some pointers (revisit)

img: full tree with pointer links

Taken together, these nodes form a tree where the edges are hash pointer links 

---

# Merkle Trees for version control

Git and Mercurial use Merkle trees:
- Commit history
- Directory trees

Enables:
- Quick diffing
- Structural sharing
- Simplified caching

---

# Haskell Code Sketch: DirTree

simple directory tree (without any hash annotations):

```haskell
data DirTree = DirTree { entities :: [(FilePath, FileFileTreeEntity)]}

data FileTreeEntity
  = FileEntity String
  | DirEntity  DirTree
```

Note that top-level directory has no name (as in git)

---

# Haskell Code Sketch: Low-level Structure

```haskell
newtype Hash = Hash { unHash :: Int}

data HashableDirLayer = HashableDir { entities :: [(FilePath, HashableFileTreeEntity)]}

data HashableFileTreeEntity
  = HashableFileEntity String 
  | HashableDirEntity  Hash
```

Only difference: recursive `DirTree` parameter replaced with `Hash` pointer.

---

# Haskell Code Sketch: Refactor

There's a lot of code duplication here. We know only one thing changes (the recursive parameter) between `Dir` and `HashableDirLayer`, can we instead use one type parameterized over that? 

```haskell
data DirLayer a = DirLayer { entities :: [(FilePath, FileTreeEntity a)]}

data FileTreeEntity a
  = FileEntity String 
  | DirEntity  a

```

Given this, a hashable layer is just:

```haskell
newtype Hash = Hash { unHash :: Int}

type HashableDirLayer = DirLayer Hash
```

---

# Haskell Code Sketch: Refactor

But how do we represent the recursive case? Conceptually, we want something like this: 

```haskell
myDir :: ???
myDir = DirLayer
      [ ("README.md" , FileEntity "foo")
      , ("dir2"      , DirEntity $ DirLayer [("Foo.hs", FileEntity "baz")])
      ]
```

But the resulting type is a mess: `Dirlayer (DirLayer (DirLayer ...))` 

---

# Haskell Code Sketch: Fix

```haskell
data DirLayer a = DirLayer { entities :: [(FilePath, FileTreeEntity a)]}

data FileTreeEntity a
  = FileEntity String 
  | DirEntity  a

```

Solution: take the type-level fix point of `Dir`

```haskell
newtype Fix f = Fix { unFix :: f (Fix f) }

type DirTree = Fix DirLayer

myDir :: DirTree
myDir = Fix $ DirLayer
      [ ("README.md" , FileEntity "foo")
      , ("dir2"      , DirEntity $ Fix $ DirLayer [("Foo.hs", FileEntity "baz")])
      ]

```

---

# Recursion Schemes!

- This format gives us access to some truly powerful abstractions:
- Recursion schemes let us _generalize_ over fold and unfold
- Like for loops _generalize_ over goto

---

# Hashing a directory tree

```haskell
hashLayer :: DirLayer Hash -> Hash
hashLayer = hash . AE.encode
```

All you need to do is write a function to hash a layer!

```haskell
cata :: Functor f => (f a -> a) -> Fix f -> a

hashDirTree :: DirTree -> Hash
hashDirTree = cata hashLayer
```


---

# Writing a directory tree to disk

```haskell
writeLayer :: DirLayer Hash -> IO Hash
writeLayer layer = do
  let h = hashLayer layer
      path = hashToPath h
  AE.encodeFile path layer -- write dir layer to path
  pure h
```

All you need to do is write a function to write a layer to the store!

```haskell
cataM :: (Monad m, Traversable f) => (f a -> m a) -> Fix f -> m a

writeDirTree :: DirTree -> IO Hash
writeDirTree = cataM writeLayer
```

---

# Reading a directory tree from disk

```haskell
readLayer :: Hash -> IO (DirLayer Hash)
readLayer h = do
  res <- AE.decodeFileStrict (hashToPath h)
  case res of
    Nothing -> fail "hash deref failed"
    Maybe x -> pure x
```

All you need to do is write a function to retrieve a layer from the store!

```haskell
anaM :: (Monad m, Traversable f) => (a -> m (f a)) -> a -> m (Fix f)

readDirTree :: Hash -> IO DirTree
readDirTree = anaM writeLayer
```

---

# Other Benefits

This formulation also simplifies lazy traversal. We'll examine how in more detail in later sessions, but here's a teaser:

```haskell
type LazyMerkleDir m = Fix ((Hash,) `Compose` m `Compose` DirLayer)

readDirLazy :: Hash -> LazyMerkleDir IO
readDirLazy = ana (Compose $ readLayer)
  where
    alg h = Compose (h, Compose $ readLayer h)
```

---

# Break for questions

Next talk:
- Use recursion schemes to implement some simple fold/unfold type functions
- Write a directory diffing algorithm to compare two `DirTree`s

---




    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>